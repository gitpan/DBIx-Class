Schema versioning/deployment ideas from Jess (with input from theorbtwo and mst):
1) Add a method to storage to:
 - take args of DB type, version, and optional file/pathname
 - create an SQL file, via SQLT, for the current schema
 - passing prev. version + version will create an sqlt-diff'ed upgrade file, such as
  - $preversion->$currentversion-$dbtype.sql, which contains ALTER foo statements.
2) Make deploy/deploy_statements able to to load from the appropriate file, for the current DB, or on the fly? - Compare against current schema version..
3) Add an on_connect_cb (callback) thingy to storage.
4) create a component to deploy version/updates:
 - it hooks itself into on_connect_cb ?
 - when run it:
   - Attempts or prompts a backup of the database. (commands for these per-rdbms can be stored in storage::dbi::<dbtype> ?)
   - Checks the version of the current schema being used
   - Compares it to some schema table containing the installed version
   - If none such exists, we can attempt to sqlt-diff the DB structure with the schema
   - If version does exist, we use an array of user-defined upgrade paths,
    eg: version = '3x.'; schema = '1.x', upgrade paths = ('1.x->2.x', '2.x->3.x')
   - Find the appropriate upgrade-path file, parse into two chunks:
    a) the commands which do not contain "DROP"
    b) the ones that do
   - Calls user callbacks for "pre-upgrade"
   - Runs the first set of commands on the DB
   - Calls user callbacks for "post-alter"
   - Runs drop commands
   - Calls user callbacks for "post-drop"
 - The user will need to define (or ignore) the following callbacks:
  - "pre-upgrade", any code to be run before the upgrade, called with schema object, version-from, version-to, db-type .. bear in mind that here any new fields in the schema will not work, but can be used via scalarrefs.
  - "post-alter", this is the main callback, at this stage, all old and new fields will be available, to allow data migration.
  - "post-drop", this is the clean-up stage, now only new fields are available.

