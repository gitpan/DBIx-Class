=for comment POD_DERIVED_INDEX_GENERATED
The following documentation is automatically generated.  Please do not edit
this file, but rather the original, inline with DBIx::Class::Storage::DBI::Sybase::ASE
at lib/DBIx/Class/Storage/DBI/Sybase/ASE.pm
(on the system that originally ran this).
If you do edit this file, and don't want your changes to be removed, make
sure you change the first line.

=cut

=head1 NAME

DBIx::Class::Storage::DBI::Sybase::ASE - Sybase ASE SQL Server support for
DBIx::Class

=head1 SYNOPSIS

This subclass supports L<DBD::Sybase> for real (non-Microsoft) Sybase databases.

=head1 DESCRIPTION

If your version of Sybase does not support placeholders, then your storage will
be reblessed to L<DBIx::Class::Storage::DBI::Sybase::ASE::NoBindVars>.
You can also enable that driver explicitly, see the documentation for more
details.

With this driver there is unfortunately no way to get the C<last_insert_id>
without doing a C<SELECT MAX(col)>. This is done safely in a transaction
(locking the table.) See L</INSERTS WITH PLACEHOLDERS>.

A recommended L<connect_info|DBIx::Class::Storage::DBI/connect_info> setting:

  on_connect_call => [['datetime_setup'], ['blob_setup', log_on_update => 0]]

=head1 METHODS

=head2 connect_call_blob_setup

Used as:

  on_connect_call => [ [ 'blob_setup', log_on_update => 0 ] ]

Does C<< $dbh->{syb_binary_images} = 1; >> to return C<IMAGE> data as raw binary
instead of as a hex string.

Recommended.

Also sets the C<log_on_update> value for blob write operations. The default is
C<1>, but C<0> is better if your database is configured for it.

See
L<DBD::Sybase/Handling_IMAGE/TEXT_data_with_syb_ct_get_data()/syb_ct_send_data()>.

=head2 connect_call_datetime_setup

Used as:

  on_connect_call => 'datetime_setup'

In L<connect_info|DBIx::Class::Storage::DBI/connect_info> to set:

  $dbh->syb_date_fmt('ISO_strict'); # output fmt: 2004-08-21T14:36:48.080Z
  $dbh->do('set dateformat mdy');   # input fmt:  08/13/1979 18:08:55.080

This works for both C<DATETIME> and C<SMALLDATETIME> columns, note that
C<SMALLDATETIME> columns only have minute precision.

=head1 Schema::Loader Support

As of version C<0.05000>, L<DBIx::Class::Schema::Loader> should work well with
most versions of Sybase ASE.

=head1 FreeTDS

This driver supports L<DBD::Sybase> compiled against FreeTDS
(L<http://www.freetds.org/>) to the best of our ability, however it is
recommended that you recompile L<DBD::Sybase> against the Sybase Open Client
libraries. They are a part of the Sybase ASE distribution:

The Open Client FAQ is here:
L<http://www.isug.com/Sybase_FAQ/ASE/section7.html>.

Sybase ASE for Linux (which comes with the Open Client libraries) may be
downloaded here: L<http://response.sybase.com/forms/ASE_Linux_Download>.

To see if you're using FreeTDS run:

  perl -MDBI -le 'my $dbh = DBI->connect($dsn, $user, $pass); print $dbh->{syb_oc_version}'

It is recommended to set C<tds version> for your ASE server to C<5.0> in
C</etc/freetds/freetds.conf>.

Some versions or configurations of the libraries involved will not support
placeholders, in which case the storage will be reblessed to
L<DBIx::Class::Storage::DBI::Sybase::ASE::NoBindVars>.

In some configurations, placeholders will work but will throw implicit type
conversion errors for anything that's not expecting a string. In such a case,
the C<auto_cast> option from L<DBIx::Class::Storage::DBI::AutoCast> is
automatically set, which you may enable on connection with
L<connect_call_set_auto_cast|DBIx::Class::Storage::DBI::AutoCast/connect_call_set_auto_cast>.
The type info for the C<CAST>s is taken from the
L<DBIx::Class::ResultSource/data_type> definitions in your Result classes, and
are mapped to a Sybase type (if it isn't already) using a mapping based on
L<SQL::Translator>.

In other configurations, placeholders will work just as they do with the Sybase
Open Client libraries.

Inserts or updates of TEXT/IMAGE columns will B<NOT> work with FreeTDS.

=head1 INSERTS WITH PLACEHOLDERS

With placeholders enabled, inserts are done in a transaction so that there are
no concurrency issues with getting the inserted identity value using
C<SELECT MAX(col)>, which is the only way to get the C<IDENTITY> value in this
mode.

In addition, they are done on a separate connection so that it's possible to
have active cursors when doing an insert.

When using C<DBIx::Class::Storage::DBI::Sybase::ASE::NoBindVars> transactions
are unnecessary and not used, as there are no concurrency issues with C<SELECT
@@IDENTITY> which is a session variable.

=head1 TRANSACTIONS

Due to limitations of the TDS protocol and L<DBD::Sybase>, you cannot begin a
transaction while there are active cursors, nor can you use multiple active
cursors within a transaction. An active cursor is, for example, a
L<ResultSet|DBIx::Class::ResultSet> that has been executed using C<next> or
C<first> but has not been exhausted or L<reset|DBIx::Class::ResultSet/reset>.

For example, this will not work:

  $schema->txn_do(sub {
    my $rs = $schema->resultset('Book');
    while (my $row = $rs->next) {
      $schema->resultset('MetaData')->create({
        book_id => $row->id,
        ...
      });
    }
  });

This won't either:

  my $first_row = $large_rs->first;
  $schema->txn_do(sub { ... });

Transactions done for inserts in C<AutoCommit> mode when placeholders are in use
are not affected, as they are done on an extra database handle.

Some workarounds:

=over 4

=item * use L<DBIx::Class::Storage::DBI::Replicated>

=item * L<connect|DBIx::Class::Schema/connect> another L<Schema|DBIx::Class::Schema>

=item * load the data from your cursor with L<DBIx::Class::ResultSet/all>

=back

=head1 MAXIMUM CONNECTIONS

The TDS protocol makes separate connections to the server for active statements
in the background. By default the number of such connections is limited to 25,
on both the client side and the server side.

This is a bit too low for a complex L<DBIx::Class> application, so on connection
the client side setting is set to C<256> (see L<DBD::Sybase/maxConnect>.) You
can override it to whatever setting you like in the DSN.

See
L<http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.sag1/html/sag1/sag1272.htm>
for information on changing the setting on the server side.

=head1 DATES

See L</connect_call_datetime_setup> to setup date formats
for L<DBIx::Class::InflateColumn::DateTime>.

=head1 LIMITED QUERIES

Because ASE does not have a good way to limit results in SQL that works for all
types of queries, the limit dialect is set to
L<GenericSubQ|SQL::Abstract::Limit/GenericSubQ>.

Fortunately, ASE and L<DBD::Sybase> support cursors properly, so when
L<GenericSubQ|SQL::Abstract::Limit/GenericSubQ> is too slow you can use
the L<software_limit|DBIx::Class::ResultSet/software_limit>
L<DBIx::Class::ResultSet> attribute to simulate limited queries by skipping over
records.

=head1 TEXT/IMAGE COLUMNS

L<DBD::Sybase> compiled with FreeTDS will B<NOT> allow you to insert or update
C<TEXT/IMAGE> columns.

Setting C<< $dbh->{LongReadLen} >> will also not work with FreeTDS use either:

  $schema->storage->dbh->do("SET TEXTSIZE $bytes");

or

  $schema->storage->set_textsize($bytes);

instead.

However, the C<LongReadLen> you pass in
L<connect_info|DBIx::Class::Storage::DBI/connect_info> is used to execute the
equivalent C<SET TEXTSIZE> command on connection.

See L</connect_call_blob_setup> for a
L<connect_info|DBIx::Class::Storage::DBI/connect_info> setting you need to work
with C<IMAGE> columns.

=head1 BULK API

The experimental L<DBD::Sybase> Bulk API support is used for
L<populate|DBIx::Class::ResultSet/populate> in B<void> context, in a transaction
on a separate connection.

To use this feature effectively, use a large number of rows for each
L<populate|DBIx::Class::ResultSet/populate> call, eg.:

  while (my $rows = $data_source->get_100_rows()) {
    $rs->populate($rows);
  }

B<NOTE:> the L<add_columns|DBIx::Class::ResultSource/add_columns>
calls in your C<Result> classes B<must> list columns in database order for this
to work. Also, you may have to unset the C<LANG> environment variable before
loading your app, as C<BCP -Y> is not yet supported in DBD::Sybase .

When inserting IMAGE columns using this method, you'll need to use
L</connect_call_blob_setup> as well.

=head1 COMPUTED COLUMNS

If you have columns such as:

  created_dtm AS getdate()

represent them in your Result classes as:

  created_dtm => {
    data_type => undef,
    default_value => \'getdate()',
    is_nullable => 0,
    inflate_datetime => 1,
  }

The C<data_type> must exist and must be C<undef>. Then empty inserts will work
on tables with such columns.

=head1 TIMESTAMP COLUMNS

C<timestamp> columns in Sybase ASE are not really timestamps, see:
L<http://dba.fyicenter.com/Interview-Questions/SYBASE/The_timestamp_datatype_in_Sybase_.html>.

They should be defined in your Result classes as:

  ts => {
    data_type => 'timestamp',
    is_nullable => 0,
    inflate_datetime => 0,
  }

The C<< <inflate_datetime = >> 0>> is necessary if you use
L<DBIx::Class::InflateColumn::DateTime>, and most people do, and still want to
be able to read these values.

The values will come back as hexadecimal.

=head1 TODO

=over 4

=item *

Transitions to AutoCommit=0 (starting a transaction) mode by exhausting
any active cursors, using eager cursors.

=item *

Real limits and limited counts using stored procedures deployed on startup.

=item *

Blob update with a LIKE query on a blob, without invalidating the WHERE condition.

=item *

bulk_insert using prepare_cached (see comments.)

=back

=head1 INHERITED METHODS

=over 4

=item L<DBIx::Class::Storage::DBI>

L<bind_attribute_by_data_type|DBIx::Class::Storage::DBI/bind_attribute_by_data_type>, L<build_datetime_parser|DBIx::Class::Storage::DBI/build_datetime_parser>, L<columns_info_for|DBIx::Class::Storage::DBI/columns_info_for>, L<connect_call_do_sql|DBIx::Class::Storage::DBI/connect_call_do_sql>, L<connect_info|DBIx::Class::Storage::DBI/connect_info>, L<connected|DBIx::Class::Storage::DBI/connected>, L<create_ddl_dir|DBIx::Class::Storage::DBI/create_ddl_dir>, L<datetime_parser|DBIx::Class::Storage::DBI/datetime_parser>, L<datetime_parser_type|DBIx::Class::Storage::DBI/datetime_parser_type>, L<dbh|DBIx::Class::Storage::DBI/dbh>, L<dbh_do|DBIx::Class::Storage::DBI/dbh_do>, L<delete|DBIx::Class::Storage::DBI/delete>, L<deploy|DBIx::Class::Storage::DBI/deploy>, L<deployment_statements|DBIx::Class::Storage::DBI/deployment_statements>, L<disconnect_call_do_sql|DBIx::Class::Storage::DBI/disconnect_call_do_sql>, L<ensure_connected|DBIx::Class::Storage::DBI/ensure_connected>, L<get_dbms_capability|DBIx::Class::Storage::DBI/get_dbms_capability>, L<get_use_dbms_capability|DBIx::Class::Storage::DBI/get_use_dbms_capability>, L<is_datatype_numeric|DBIx::Class::Storage::DBI/is_datatype_numeric>, L<is_replicating|DBIx::Class::Storage::DBI/is_replicating>, L<lag_behind_master|DBIx::Class::Storage::DBI/lag_behind_master>, L<new|DBIx::Class::Storage::DBI/new>, L<on_connect_call|DBIx::Class::Storage::DBI/on_connect_call>, L<on_connect_do|DBIx::Class::Storage::DBI/on_connect_do>, L<on_disconnect_call|DBIx::Class::Storage::DBI/on_disconnect_call>, L<on_disconnect_do|DBIx::Class::Storage::DBI/on_disconnect_do>, L<relname_to_table_alias|DBIx::Class::Storage::DBI/relname_to_table_alias>, L<select|DBIx::Class::Storage::DBI/select>, L<select_single|DBIx::Class::Storage::DBI/select_single>, L<set_dbms_capability|DBIx::Class::Storage::DBI/set_dbms_capability>, L<set_use_dbms_capability|DBIx::Class::Storage::DBI/set_use_dbms_capability>, L<source_bind_attributes|DBIx::Class::Storage::DBI/source_bind_attributes>, L<sql_limit_dialect|DBIx::Class::Storage::DBI/sql_limit_dialect>, L<sql_maker|DBIx::Class::Storage::DBI/sql_maker>, L<sql_maker_class|DBIx::Class::Storage::DBI/sql_maker_class>, L<sql_name_sep|DBIx::Class::Storage::DBI/sql_name_sep>, L<sql_quote_char|DBIx::Class::Storage::DBI/sql_quote_char>, L<sqlt_type|DBIx::Class::Storage::DBI/sqlt_type>, L<sth|DBIx::Class::Storage::DBI/sth>, L<svp_begin|DBIx::Class::Storage::DBI/svp_begin>, L<svp_release|DBIx::Class::Storage::DBI/svp_release>, L<svp_rollback|DBIx::Class::Storage::DBI/svp_rollback>, L<txn_begin|DBIx::Class::Storage::DBI/txn_begin>, L<txn_commit|DBIx::Class::Storage::DBI/txn_commit>, L<txn_do|DBIx::Class::Storage::DBI/txn_do>, L<txn_rollback|DBIx::Class::Storage::DBI/txn_rollback>, L<with_deferred_fk_checks|DBIx::Class::Storage::DBI/with_deferred_fk_checks>

=item L<DBIx::Class::Storage>

L<cursor|DBIx::Class::Storage/cursor>, L<debugcb|DBIx::Class::Storage/debugcb>, L<debugfh|DBIx::Class::Storage/debugfh>, L<savepoints|DBIx::Class::Storage/savepoints>, L<set_schema|DBIx::Class::Storage/set_schema>, L<throw_exception|DBIx::Class::Storage/throw_exception>, L<transaction_depth|DBIx::Class::Storage/transaction_depth>, L<txn_scope_guard|DBIx::Class::Storage/txn_scope_guard>

=back

=head1 AUTHOR

See L<DBIx::Class/AUTHOR> and L<DBIx::Class/CONTRIBUTORS>.

=head1 LICENSE

You may distribute this code under the same terms as Perl itself.

